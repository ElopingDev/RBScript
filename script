--[[ ESP Menu Script - Camlock on Right Mouse Button ]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")

local localPlayer = Players.LocalPlayer
if not localPlayer then Players.PlayerAdded:Wait(); localPlayer = Players.LocalPlayer end
local playerGui = localPlayer:WaitForChild("PlayerGui")
local currentCamera = workspace.CurrentCamera

-- Configuration & State
local featureStates = { ["ESP Box"] = false, ["Chams"] = false, ["Fly"] = false, ["Camlock"] = false }
local featureColors = { ["ESP Box"] = Color3.fromRGB(128, 0, 128), ["Chams"] = Color3.fromRGB(180, 0, 255) }
local BOX_THICKNESS = 2; local BOX_SCALING_BASE = 3000; local BOX_MIN_SIZE = 30; local BOX_MAX_SIZE = 180
local flySpeed = 50; local flyKeybind = Enum.KeyCode.F
local camlockFOV = 100; local camlockTarget = nil
local CAMERA_OFFSET = Vector3.new(0, 3, 10)
local CAMLOCK_LERP_SPEED = 0.2
local isMenuVisible = true; local activeBillboards = {}; local activeChamsHighlights = {}
local currentEditingFeature = nil; local activeTab = "Visuals"
local isFlying = false; local isChangingFlyKeybind = false; local flyVelocityInstance = nil; local flyGyroInstance = nil; local flightControlConnection = nil
local isCamlocking = false
local originalCameraType = Enum.CameraType.Custom

-- Menu UI Elements (References)
local screenGui, menuFrame, colorPickerFrame, flySettingsFrame = nil, nil, nil, nil
local hexInput, colorPreview = nil, nil; local flySpeedInput = nil; local flyKeybindButton = nil
local camlockFovInput = nil; local tabContentFrames = {}; local tabButtons = {}; local featureButtons = {}

-- Action names for ContextActionService
local MENU_TOGGLE_ACTION = "ToggleEspMenuAction"
local CAMLOCK_MOUSE_SINK_ACTION = "CamlockMouseSinkAction"

--[[ UI Creation ... (UI Code is identical to the previous version, snipped for brevity) ]]
screenGui = Instance.new("ScreenGui"); screenGui.Name = "EspMenuGUI"; screenGui.ResetOnSpawn = false; screenGui.IgnoreGuiInset = true; screenGui.DisplayOrder = 10
menuFrame = Instance.new("Frame"); menuFrame.Name = "MenuFrame"; menuFrame.Size = UDim2.new(0, 280, 0, 220); menuFrame.Position = UDim2.new(0.5, -140, 0.5, -110); menuFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35); menuFrame.BorderColor3 = Color3.fromRGB(80, 80, 80); menuFrame.BorderSizePixel = 1; menuFrame.Active = true; menuFrame.Draggable = true; menuFrame.Visible = isMenuVisible; menuFrame.ClipsDescendants = true; menuFrame.Parent = screenGui; local mc = Instance.new("UICorner"); mc.CornerRadius = UDim.new(0, 4); mc.Parent = menuFrame
local titleBar = Instance.new("Frame"); titleBar.Name = "TitleBar"; titleBar.Size = UDim2.new(1, 0, 0, 25); titleBar.Position = UDim2.new(0, 0, 0, 0); titleBar.BackgroundColor3 = Color3.fromRGB(55, 55, 55); titleBar.BorderSizePixel = 0; titleBar.Parent = menuFrame; local tc = Instance.new("UICorner"); tc.CornerRadius = UDim.new(0, 4); tc.Parent = titleBar; local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1, -10, 1, 0); titleLabel.Position = UDim2.new(0, 5, 0, 0); titleLabel.BackgroundTransparency = 1; titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220); titleLabel.Font = Enum.Font.SourceSansSemibold; titleLabel.TextSize = 16; titleLabel.Text = "ESP Menu"; titleLabel.TextXAlignment = Enum.TextXAlignment.Left; titleLabel.Parent = titleBar
local tabButtonContainer = Instance.new("Frame"); tabButtonContainer.Name = "TabButtonContainer"; tabButtonContainer.Size = UDim2.new(1, 0, 0, 30); tabButtonContainer.Position = UDim2.new(0, 0, 0, 25); tabButtonContainer.BackgroundTransparency = 1; tabButtonContainer.BorderSizePixel = 0; tabButtonContainer.Parent = menuFrame; local tabListLayout = Instance.new("UIListLayout"); tabListLayout.FillDirection = Enum.FillDirection.Horizontal; tabListLayout.Padding = UDim.new(0, 5); tabListLayout.VerticalAlignment = Enum.VerticalAlignment.Center; tabListLayout.Parent = tabButtonContainer
local mainContentContainer = Instance.new("Frame"); mainContentContainer.Name = "MainContentContainer"; mainContentContainer.Size = UDim2.new(1, -10, 1, -60); mainContentContainer.Position = UDim2.new(0, 5, 0, 58); mainContentContainer.BackgroundTransparency = 1; mainContentContainer.BorderSizePixel = 0; mainContentContainer.ClipsDescendants = true; mainContentContainer.Parent = menuFrame
local function updateTabButtons() for name, button in pairs(tabButtons) do local isActive = (name == activeTab); button.BackgroundColor3 = isActive and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(50, 50, 50); button.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180) end end
local function createTab(tabName) local contentFrame = Instance.new("Frame"); contentFrame.Name = tabName .. "Content"; contentFrame.Size = UDim2.new(1, 0, 1, 0); contentFrame.Position = UDim2.new(0, 0, 0, 0); contentFrame.BackgroundTransparency = 1; contentFrame.BorderSizePixel = 0; contentFrame.Visible = (tabName == activeTab); contentFrame.Parent = mainContentContainer; tabContentFrames[tabName] = contentFrame; local listLayout = Instance.new("UIListLayout"); listLayout.Padding = UDim.new(0, 5); listLayout.SortOrder = Enum.SortOrder.LayoutOrder; listLayout.Parent = contentFrame; local tabButton = Instance.new("TextButton"); tabButton.Name = tabName .. "Tab"; tabButton.Size = UDim2.new(0, 80, 1, -4); tabButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50); tabButton.TextColor3 = Color3.fromRGB(180, 180, 180); tabButton.Font = Enum.Font.SourceSans; tabButton.TextSize = 14; tabButton.Text = tabName; tabButton.Parent = tabButtonContainer; local tbc = Instance.new("UICorner"); tbc.CornerRadius = UDim.new(0, 3); tbc.Parent = tabButton; tabButtons[tabName] = tabButton; tabButton.MouseButton1Click:Connect(function() if activeTab == tabName then return end; if tabContentFrames[activeTab] then tabContentFrames[activeTab].Visible = false end; contentFrame.Visible = true; activeTab = tabName; updateTabButtons() end); return contentFrame end
local visualsContent = createTab("Visuals"); local movementContent = createTab("Movement"); local aimContent = createTab("Aim"); updateTabButtons()
colorPickerFrame = Instance.new("Frame"); colorPickerFrame.Name = "ColorPickerFrame"; colorPickerFrame.Size = UDim2.new(0, 200, 0, 100); colorPickerFrame.Position = UDim2.new(0.5, -100, 0.5, -120); colorPickerFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45); colorPickerFrame.BorderColor3 = Color3.fromRGB(90, 90, 90); colorPickerFrame.BorderSizePixel = 1; colorPickerFrame.Visible = false; colorPickerFrame.ClipsDescendants = true; colorPickerFrame.Parent = screenGui; local pc = Instance.new("UICorner"); pc.CornerRadius = UDim.new(0, 4); pc.Parent = colorPickerFrame; local pickerTitle = Instance.new("TextLabel"); pickerTitle.Name = "PickerTitle"; pickerTitle.Size = UDim2.new(1, -10, 0, 20); pickerTitle.Position = UDim2.new(0, 5, 0, 3); pickerTitle.BackgroundTransparency = 1; pickerTitle.TextColor3 = Color3.fromRGB(200, 200, 200); pickerTitle.Font = Enum.Font.SourceSans; pickerTitle.TextSize = 14; pickerTitle.Text = "Edit Color"; pickerTitle.TextXAlignment = Enum.TextXAlignment.Left; pickerTitle.Parent = colorPickerFrame; local hexLabel = Instance.new("TextLabel"); hexLabel.Name = "HexLabel"; hexLabel.Size = UDim2.new(0.25, 0, 0, 25); hexLabel.Position = UDim2.new(0, 5, 0, 30); hexLabel.BackgroundTransparency = 1; hexLabel.TextColor3 = Color3.fromRGB(180, 180, 180); hexLabel.Font = Enum.Font.SourceSans; hexLabel.TextSize = 14; hexLabel.Text = "Hex:"; hexLabel.TextXAlignment = Enum.TextXAlignment.Right; hexLabel.Parent = colorPickerFrame; hexInput = Instance.new("TextBox"); hexInput.Name = "HexInput"; hexInput.Size = UDim2.new(0.4, 0, 0, 25); hexInput.Position = UDim2.new(0.25, 10, 0, 30); hexInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); hexInput.TextColor3 = Color3.fromRGB(220, 220, 220); hexInput.Font = Enum.Font.SourceSans; hexInput.TextSize = 14; hexInput.ClearTextOnFocus = false; hexInput.Text = "FFFFFF"; hexInput.Parent = colorPickerFrame; local hic = Instance.new("UICorner"); hic.CornerRadius = UDim.new(0, 3); hic.Parent = hexInput; colorPreview = Instance.new("Frame"); colorPreview.Name = "ColorPreview"; colorPreview.Size = UDim2.new(0.25, -15, 0, 25); colorPreview.Position = UDim2.new(0.7, 10, 0, 30); colorPreview.BackgroundColor3 = Color3.fromRGB(255, 255, 255); colorPreview.BorderSizePixel = 1; colorPreview.BorderColor3 = Color3.fromRGB(100,100,100); colorPreview.Parent = colorPickerFrame; local prvC = Instance.new("UICorner"); prvC.CornerRadius = UDim.new(0, 3); prvC.Parent=colorPreview; applyButton = Instance.new("TextButton"); applyButton.Name = "ApplyButton"; applyButton.Size = UDim2.new(0.45, -5, 0, 25); applyButton.Position = UDim2.new(0, 5, 1, -30); applyButton.BackgroundColor3 = Color3.fromRGB(80, 120, 80); applyButton.TextColor3 = Color3.fromRGB(220, 220, 220); applyButton.Font = Enum.Font.SourceSansSemibold; applyButton.TextSize = 14; applyButton.Text = "Apply"; applyButton.Parent = colorPickerFrame; local ac = Instance.new("UICorner"); ac.CornerRadius = UDim.new(0, 3); ac.Parent = applyButton; closeButton = Instance.new("TextButton"); closeButton.Name = "CloseButton"; closeButton.Size = UDim2.new(0.45, -5, 0, 25); closeButton.Position = UDim2.new(0.5, 5, 1, -30); closeButton.BackgroundColor3 = Color3.fromRGB(120, 80, 80); closeButton.TextColor3 = Color3.fromRGB(220, 220, 220); closeButton.Font = Enum.Font.SourceSansSemibold; closeButton.TextSize = 14; closeButton.Text = "Close"; closeButton.Parent = colorPickerFrame; local cc = Instance.new("UICorner"); cc.CornerRadius = UDim.new(0, 3); cc.Parent = closeButton; local function parseHexColor(hex) hex = string.gsub(hex or "", "#", ""); if string.len(hex) ~= 6 then return nil end; if not string.match(hex, "^[0-9a-fA-F]+$") then return nil end; local s, c = pcall(Color3.fromHex, hex); if s then return c else return nil end end; local function updatePreview() local c = parseHexColor(hexInput.Text); if c then colorPreview.BackgroundColor3 = c; hexInput.BorderColor3 = Color3.fromRGB(60,60,60) else colorPreview.BackgroundColor3 = Color3.fromRGB(80, 80, 80); hexInput.BorderColor3 = Color3.fromRGB(255,0,0) end end; hexInput:GetPropertyChangedSignal("Text"):Connect(updatePreview); hexInput.FocusLost:Connect(updatePreview); local function openColorPicker(fName) currentEditingFeature = fName; local cC = featureColors[fName]; if cC then hexInput.Text = cC:ToHex(); updatePreview(); pickerTitle.Text = "Edit "..fName.." Color"; colorPickerFrame.Visible = true; if flySettingsFrame then flySettingsFrame.Visible = false end end end; applyButton.MouseButton1Click:Connect(function() if currentEditingFeature then local nC = parseHexColor(hexInput.Text); if nC then featureColors[currentEditingFeature] = nC; colorPickerFrame.Visible = false; currentEditingFeature = nil else print("Invalid Hex code.") end end end); closeButton.MouseButton1Click:Connect(function() colorPickerFrame.Visible = false; currentEditingFeature = nil end)
flySettingsFrame = Instance.new("Frame"); flySettingsFrame.Name = "FlySettingsFrame"; flySettingsFrame.Size = UDim2.new(0, 200, 0, 130); flySettingsFrame.Position = UDim2.new(0.5, -100, 0.5, -135); flySettingsFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45); flySettingsFrame.BorderColor3 = Color3.fromRGB(90, 90, 90); flySettingsFrame.BorderSizePixel = 1; flySettingsFrame.Visible = false; flySettingsFrame.ClipsDescendants = true; flySettingsFrame.Parent = screenGui; local fsc = Instance.new("UICorner"); fsc.CornerRadius = UDim.new(0, 4); fsc.Parent = flySettingsFrame; local flySettingsTitle = Instance.new("TextLabel"); flySettingsTitle.Name = "FlySettingsTitle"; flySettingsTitle.Size = UDim2.new(1, -10, 0, 20); flySettingsTitle.Position = UDim2.new(0, 5, 0, 3); flySettingsTitle.BackgroundTransparency = 1; flySettingsTitle.TextColor3 = Color3.fromRGB(200, 200, 200); flySettingsTitle.Font = Enum.Font.SourceSans; flySettingsTitle.TextSize = 14; flySettingsTitle.Text = "Fly Settings"; flySettingsTitle.TextXAlignment = Enum.TextXAlignment.Left; flySettingsTitle.Parent = flySettingsFrame; local speedFrame = Instance.new("Frame"); speedFrame.Name = "FlySpeedFrame"; speedFrame.Size = UDim2.new(1, -10, 0, 25); speedFrame.Position = UDim2.new(0, 5, 0, 30); speedFrame.BackgroundTransparency = 1; speedFrame.Parent = flySettingsFrame; local speedLabel = Instance.new("TextLabel"); speedLabel.Name = "Label"; speedLabel.Size = UDim2.new(0.5, -5, 1, 0); speedLabel.Position = UDim2.new(0, 0, 0, 0); speedLabel.BackgroundTransparency = 1; speedLabel.TextColor3 = Color3.fromRGB(200, 200, 200); speedLabel.Font = Enum.Font.SourceSans; speedLabel.TextSize = 14; speedLabel.Text = "Fly Speed:"; speedLabel.TextXAlignment = Enum.TextXAlignment.Left; speedLabel.Parent = speedFrame; flySpeedInput = Instance.new("TextBox"); flySpeedInput.Name = "SpeedInput"; flySpeedInput.Size = UDim2.new(0.5, 0, 1, 0); flySpeedInput.Position = UDim2.new(0.5, 0, 0, 0); flySpeedInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); flySpeedInput.TextColor3 = Color3.fromRGB(220, 220, 220); flySpeedInput.Font = Enum.Font.SourceSans; flySpeedInput.TextSize = 14; flySpeedInput.ClearTextOnFocus = false; flySpeedInput.Text = tostring(flySpeed); flySpeedInput.Parent = speedFrame; local sic = Instance.new("UICorner"); sic.CornerRadius = UDim.new(0, 3); sic.Parent = flySpeedInput; flySpeedInput.FocusLost:Connect(function(ep) if ep or true then local n = tonumber(flySpeedInput.Text); if n and n>0 then flySpeed=n; flySpeedInput.Text=tostring(flySpeed) else flySpeedInput.Text=tostring(flySpeed) end end end); local keybindFrame = Instance.new("Frame"); keybindFrame.Name = "FlyKeybindFrame"; keybindFrame.Size = UDim2.new(1, -10, 0, 25); keybindFrame.Position = UDim2.new(0, 5, 0, 60); keybindFrame.BackgroundTransparency = 1; keybindFrame.Parent = flySettingsFrame; local keybindLabel = Instance.new("TextLabel"); keybindLabel.Name = "Label"; keybindLabel.Size = UDim2.new(0.5, -5, 1, 0); keybindLabel.Position = UDim2.new(0, 0, 0, 0); keybindLabel.BackgroundTransparency = 1; keybindLabel.TextColor3 = Color3.fromRGB(200, 200, 200); keybindLabel.Font = Enum.Font.SourceSans; keybindLabel.TextSize = 14; keybindLabel.Text = "Fly Keybind:"; keybindLabel.TextXAlignment = Enum.TextXAlignment.Left; keybindLabel.Parent = keybindFrame; flyKeybindButton = Instance.new("TextButton"); flyKeybindButton.Name = "KeybindButton"; flyKeybindButton.Size = UDim2.new(0.5, 0, 1, 0); flyKeybindButton.Position = UDim2.new(0.5, 0, 0, 0); flyKeybindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220); flyKeybindButton.Font = Enum.Font.SourceSans; flyKeybindButton.TextSize = 14; flyKeybindButton.Text = flyKeybind.Name; flyKeybindButton.Parent = keybindFrame; local kbc = Instance.new("UICorner"); kbc.CornerRadius = UDim.new(0, 3); kbc.Parent = flyKeybindButton; flyKeybindButton.MouseButton1Click:Connect(function() if isChangingFlyKeybind then return end; isChangingFlyKeybind = true; flyKeybindButton.Text = "[Press Key]"; flyKeybindButton.TextColor3 = Color3.fromRGB(255,255,0) end); local flySettingsCloseButton = Instance.new("TextButton"); flySettingsCloseButton.Name = "CloseButton"; flySettingsCloseButton.Size = UDim2.new(1, -10, 0, 25); flySettingsCloseButton.Position = UDim2.new(0, 5, 1, -30); flySettingsCloseButton.BackgroundColor3 = Color3.fromRGB(120, 80, 80); flySettingsCloseButton.TextColor3 = Color3.fromRGB(220, 220, 220); flySettingsCloseButton.Font = Enum.Font.SourceSansSemibold; flySettingsCloseButton.TextSize = 14; flySettingsCloseButton.Text = "Close"; flySettingsCloseButton.Parent = flySettingsFrame; local fscc = Instance.new("UICorner"); fscc.CornerRadius = UDim.new(0, 3); fscc.Parent = flySettingsCloseButton; flySettingsCloseButton.MouseButton1Click:Connect(function() flySettingsFrame.Visible = false; if isChangingFlyKeybind then isChangingFlyKeybind = false; flyKeybindButton.Text = flyKeybind.Name; flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220) end end)
local function openFlySettings() flySettingsFrame.Visible = true; if colorPickerFrame then colorPickerFrame.Visible = false end end
local function updateFeatureButtonAppearance(featureName) local button = featureButtons[featureName]; local isActive = featureStates[featureName]; if button then button.BackgroundColor3 = isActive and Color3.fromRGB(90, 140, 90) or Color3.fromRGB(60, 60, 60); button.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(220, 220, 220) end end
local function createFeatureToggle(featureName, order, parentFrame, showGear) local rowFrame = Instance.new("Frame"); rowFrame.Name = featureName .. "RowFrame"; rowFrame.Size = UDim2.new(1, 0, 0, 30); rowFrame.BackgroundTransparency = 1; rowFrame.LayoutOrder = order; rowFrame.Parent = parentFrame; local gearWidth = showGear and 35 or 0; local featureButton = Instance.new("TextButton"); featureButton.Name = featureName .. "Button"; featureButton.Size = UDim2.new(1, -gearWidth, 1, 0); featureButton.Position = UDim2.new(0, 0, 0, 0); featureButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); featureButton.TextColor3 = Color3.fromRGB(220, 220, 220); featureButton.Font = Enum.Font.SourceSans; featureButton.TextSize = 14; featureButton.Text = featureName; featureButton.Parent = rowFrame; local fc = Instance.new("UICorner"); fc.CornerRadius = UDim.new(0, 3); fc.Parent = featureButton; featureButtons[featureName] = featureButton; local gearButton = nil; if showGear then gearButton = Instance.new("TextButton"); gearButton.Name = "GearButton"; gearButton.Size = UDim2.new(0, 25, 1, 0); gearButton.Position = UDim2.new(1, -30, 0, 0); gearButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70); gearButton.TextColor3 = Color3.fromRGB(200, 200, 200); gearButton.Font = Enum.Font.SourceSansSemibold; gearButton.TextSize = 16; gearButton.Text = "⚙️"; gearButton.Parent = rowFrame; local gc = Instance.new("UICorner"); gc.CornerRadius = UDim.new(0, 3); gc.Parent = gearButton; if featureName == "Fly" then gearButton.MouseButton1Click:Connect(openFlySettings) elseif featureColors[featureName] then gearButton.MouseButton1Click:Connect(function() openColorPicker(featureName) end) end end; featureButton.MouseButton1Click:Connect(function() featureStates[featureName] = not featureStates[featureName]; updateFeatureButtonAppearance(featureName) end); updateFeatureButtonAppearance(featureName) end
createFeatureToggle("ESP Box", 1, visualsContent, true); createFeatureToggle("Chams", 2, visualsContent, true); createFeatureToggle("Fly", 1, movementContent, true); createFeatureToggle("Camlock", 1, aimContent, false)
local fovFrame = Instance.new("Frame"); fovFrame.Name = "CamlockFovFrame"; fovFrame.Size = UDim2.new(1, 0, 0, 25); fovFrame.BackgroundTransparency = 1; fovFrame.LayoutOrder = 2; fovFrame.Parent = aimContent; local fovLabel = Instance.new("TextLabel"); fovLabel.Name = "Label"; fovLabel.Size = UDim2.new(0.5, -5, 1, 0); fovLabel.Position = UDim2.new(0, 0, 0, 0); fovLabel.BackgroundTransparency = 1; fovLabel.TextColor3 = Color3.fromRGB(200, 200, 200); fovLabel.Font = Enum.Font.SourceSans; fovLabel.TextSize = 14; fovLabel.Text = "Lock FOV:"; fovLabel.TextXAlignment = Enum.TextXAlignment.Left; fovLabel.Parent = fovFrame; camlockFovInput = Instance.new("TextBox"); camlockFovInput.Name = "FovInput"; camlockFovInput.Size = UDim2.new(0.5, 0, 1, 0); camlockFovInput.Position = UDim2.new(0.5, 0, 0, 0); camlockFovInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); camlockFovInput.TextColor3 = Color3.fromRGB(220, 220, 220); camlockFovInput.Font = Enum.Font.SourceSans; camlockFovInput.TextSize = 14; camlockFovInput.ClearTextOnFocus = false; camlockFovInput.Text = tostring(camlockFOV); camlockFovInput.Parent = fovFrame; local fic = Instance.new("UICorner"); fic.CornerRadius = UDim.new(0, 3); fic.Parent = camlockFovInput; camlockFovInput.FocusLost:Connect(function(ep) if ep or true then local n = tonumber(camlockFovInput.Text); if n and n>0 then camlockFOV=n; camlockFovInput.Text=tostring(camlockFOV) else camlockFovInput.Text=tostring(camlockFOV) end end end)

--[[ Flight Logic - Unchanged ]]
local function startFlying() local char = localPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart"); local humanoid = char and char:FindFirstChildOfClass("Humanoid"); if not hrp or not humanoid or isFlying then return end; isFlying = true; if flyVelocityInstance and flyVelocityInstance.Parent then flyVelocityInstance:Destroy() end; if flyGyroInstance and flyGyroInstance.Parent then flyGyroInstance:Destroy() end; flyVelocityInstance = Instance.new("BodyVelocity"); flyVelocityInstance.Name = "FlyVelocity"; flyVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge); flyVelocityInstance.Velocity = Vector3.zero; flyVelocityInstance.Parent = hrp; flyGyroInstance = Instance.new("BodyGyro"); flyGyroInstance.Name = "FlyGyro"; flyGyroInstance.MaxTorque = Vector3.new(400000, 400000, 400000) * 50; flyGyroInstance.P = 5000; flyGyroInstance.D = 500; flyGyroInstance.CFrame = hrp.CFrame; flyGyroInstance.Parent = hrp; if flightControlConnection then flightControlConnection:Disconnect() end; flightControlConnection = RunService.Heartbeat:Connect(controlFlight) end
local function stopFlying() if not isFlying then return end; isFlying = false; if flyVelocityInstance then flyVelocityInstance:Destroy(); flyVelocityInstance = nil end; if flyGyroInstance then flyGyroInstance:Destroy(); flyGyroInstance = nil end; if flightControlConnection then flightControlConnection:Disconnect(); flightControlConnection = nil end end
function controlFlight(dt) local char = localPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart"); if not featureStates["Fly"] or not isFlying or not flyVelocityInstance or not flyGyroInstance or not hrp then stopFlying(); return end; local finalMoveDir = Vector3.zero; local camCF = currentCamera.CFrame; if UserInputService:IsKeyDown(Enum.KeyCode.W) then finalMoveDir += camCF.LookVector end; if UserInputService:IsKeyDown(Enum.KeyCode.S) then finalMoveDir -= camCF.LookVector end; if UserInputService:IsKeyDown(Enum.KeyCode.A) then finalMoveDir -= camCF.RightVector end; if UserInputService:IsKeyDown(Enum.KeyCode.D) then finalMoveDir += camCF.RightVector end; if UserInputService:IsKeyDown(Enum.KeyCode.Space) then finalMoveDir += Vector3.new(0,1,0) end; if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.C) then finalMoveDir -= Vector3.new(0,1,0) end; local finalVelocity = Vector3.zero; if finalMoveDir.Magnitude > 0 then finalVelocity = finalMoveDir.Unit * flySpeed end; flyVelocityInstance.Velocity = finalVelocity; flyGyroInstance.CFrame = CFrame.new(hrp.Position, hrp.Position + camCF.LookVector) end
local function onCharacterAdded(char) stopFlying(); local humanoid = char:WaitForChild("Humanoid"); humanoid.Died:Connect(stopFlying) end; localPlayer.CharacterAdded:Connect(onCharacterAdded); if localPlayer.Character then onCharacterAdded(localPlayer.Character) end

--[[ Camlock Logic ]]
local function findCamlockTarget() local target = nil; local minDist = camlockFOV; local viewportSize = currentCamera.ViewportSize; local screenCenter = viewportSize / 2; for _, player in ipairs(Players:GetPlayers()) do if player ~= localPlayer and player.Character then local head = player.Character:FindFirstChild("Head"); local hrp = player.Character:FindFirstChild("HumanoidRootPart"); local targetPart = head or hrp; if targetPart then local screenPos, onScreen = currentCamera:WorldToViewportPoint(targetPart.Position); if onScreen then local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude; if dist < minDist then minDist = dist; target = targetPart end end end end end; return target end
local function updateCamlock() if not isCamlocking or not featureStates["Camlock"] then return end; local playerChar = localPlayer.Character; local hrp = playerChar and playerChar:FindFirstChild("HumanoidRootPart"); if not hrp then stopCamlock(); return end; camlockTarget = findCamlockTarget(); local targetPosition; if camlockTarget and camlockTarget.Parent then targetPosition = camlockTarget.Position else return end; local hrpCF = hrp.CFrame; local desiredCameraPosition = (hrpCF * CFrame.new(CAMERA_OFFSET)).Position; local targetCFrame = CFrame.new(desiredCameraPosition, targetPosition); currentCamera.CFrame = targetCFrame end -- Removed Lerp for instant snap
local function startCamlock() if not featureStates["Camlock"] or isCamlocking then return end; isCamlocking = true; originalCameraType = currentCamera.CameraType; currentCamera.CameraType = Enum.CameraType.Scriptable; end
local function stopCamlock() if not isCamlocking then return end; isCamlocking = false; camlockTarget = nil; currentCamera.CameraType = originalCameraType; end

--[[ Core Update Loop ]]
local function mainUpdateLoop() if not currentCamera then currentCamera = workspace.CurrentCamera return end; if featureStates["Fly"] and not isFlying then startFlying() elseif not featureStates["Fly"] and isFlying then stopFlying() end; if not featureStates["Camlock"] and isCamlocking then stopCamlock() end; local currentPlayers = Players:GetPlayers(); local playersToUpdate = {}; for _, player in ipairs(currentPlayers) do if player == localPlayer then continue end; local character = player.Character; local humanoid = character and character:FindFirstChildOfClass("Humanoid"); local hrp = humanoid and humanoid.RootPart; if character and character.Parent == workspace and humanoid and humanoid.Health > 0 and hrp then playersToUpdate[player] = true; if featureStates["ESP Box"] then local billboard = activeBillboards[player]; local boxColor = featureColors["ESP Box"]; if not billboard or not billboard.Parent then billboard = Instance.new("BillboardGui"); billboard.Name = "EspBillboard"; billboard.AlwaysOnTop = true; billboard.Size = UDim2.new(0, 100, 0, 150); billboard.Adornee = hrp; billboard.LightInfluence = 0; billboard.ResetOnSpawn = false; createBoxFrames(billboard); billboard.Parent = playerGui; activeBillboards[player] = billboard end; local distance = (hrp.Position - currentCamera.CFrame.Position).Magnitude; local scaleFactor = math.clamp(BOX_SCALING_BASE / math.max(distance, 0.1), BOX_MIN_SIZE, BOX_MAX_SIZE); billboard.Size = UDim2.new(0, scaleFactor, 0, scaleFactor * 1.5); billboard.Enabled = true; if billboard.BoxContainer then for _, frame in ipairs(billboard.BoxContainer:GetChildren()) do if frame:IsA("Frame") then frame.BackgroundColor3 = boxColor end end end else if activeBillboards[player] then if activeBillboards[player].Parent then activeBillboards[player]:Destroy() end; activeBillboards[player] = nil end end; if featureStates["Chams"] then local chamsHighlight = activeChamsHighlights[player]; local chamsColor = featureColors["Chams"]; if not chamsHighlight or not chamsHighlight.Parent then chamsHighlight = Instance.new("Highlight"); chamsHighlight.Name = "ChamsHighlight"; chamsHighlight.Adornee = character; chamsHighlight.FillColor = chamsColor; chamsHighlight.FillTransparency = 0; chamsHighlight.OutlineTransparency = 1; chamsHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; chamsHighlight.Enabled = true; chamsHighlight.Parent = character; activeChamsHighlights[player] = chamsHighlight elseif chamsHighlight.Adornee ~= character then chamsHighlight.Adornee = character; chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor else chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor end else if activeChamsHighlights[player] then if activeChamsHighlights[player].Parent then activeChamsHighlights[player]:Destroy() end; activeChamsHighlights[player] = nil end end else if activeBillboards[player] then if activeBillboards[player].Parent then activeBillboards[player]:Destroy() end; activeBillboards[player] = nil end; if activeChamsHighlights[player] then if activeChamsHighlights[player].Parent then activeChamsHighlights[player]:Destroy() end; activeChamsHighlights[player] = nil end end end; for player, billboard in pairs(activeBillboards) do if not playersToUpdate[player] then if billboard and billboard.Parent then billboard:Destroy() end; activeBillboards[player] = nil end end; for player, chamsHighlight in pairs(activeChamsHighlights) do if not playersToUpdate[player] then if chamsHighlight and chamsHighlight.Parent then chamsHighlight:Destroy() end; activeChamsHighlights[player] = nil end end; if isCamlocking then updateCamlock() end end

--[[ Input Handling ]]
local function handleMenuToggle(actionName, inputState, inputObject) if inputState == Enum.UserInputState.Begin then isMenuVisible = not isMenuVisible; if menuFrame then menuFrame.Visible = isMenuVisible end; if not isMenuVisible then if colorPickerFrame then colorPickerFrame.Visible = false; currentEditingFeature = nil end; if flySettingsFrame then flySettingsFrame.Visible = false; if isChangingFlyKeybind then isChangingFlyKeybind = false; flyKeybindButton.Text = flyKeybind.Name; flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220) end end end end; return Enum.ContextActionResult.Pass end
ContextActionService:BindAction(MENU_TOGGLE_ACTION, handleMenuToggle, false, Enum.KeyCode.RightShift)

-- Sink mouse movement when camlock is active
local function handleMouseSink(actionName, inputState, inputObject) if isCamlocking and inputState ~= Enum.UserInputState.Cancel then return Enum.ContextActionResult.Sink else return Enum.ContextActionResult.Pass end end
ContextActionService:BindActionAtPriority(CAMLOCK_MOUSE_SINK_ACTION, handleMouseSink, false, Enum.ContextActionPriority.High.Value + 1, Enum.UserInputType.MouseMovement)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent) if isChangingFlyKeybind then if input.UserInputType == Enum.UserInputType.Keyboard then if input.KeyCode ~= Enum.KeyCode.Unknown and input.KeyCode ~= Enum.KeyCode.Escape then flyKeybind = input.KeyCode; flyKeybindButton.Text = flyKeybind.Name; print("Fly keybind set to:", flyKeybind.Name) else flyKeybindButton.Text = flyKeybind.Name end; flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220); isChangingFlyKeybind = false end; return end; local UIsVisible = isMenuVisible or (colorPickerFrame and colorPickerFrame.Visible) or (flySettingsFrame and flySettingsFrame.Visible); if gameProcessedEvent and input.UserInputType ~= Enum.UserInputType.MouseButton2 and input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end; -- Allow Mouse Button 1/2 even if processed? Check this. Let's block KB if processed.
	if UIsVisible and input.UserInputType == Enum.UserInputType.Keyboard then return end -- Block KB if UI is open
    if gameProcessedEvent and input.UserInputType == Enum.UserInputType.Keyboard then return end -- Block KB if game processed it.

	if input.KeyCode == flyKeybind then if not UIsVisible then featureStates["Fly"] = not featureStates["Fly"]; updateFeatureButtonAppearance("Fly") end end
	-- Activate Camlock on Right Mouse Button Down
	if input.UserInputType == Enum.UserInputType.MouseButton2 then if featureStates["Camlock"] and not UIsVisible then startCamlock() end end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    -- Deactivate Camlock on Right Mouse Button Up
	if input.UserInputType == Enum.UserInputType.MouseButton2 then if isCamlocking then stopCamlock() end end
end)

--[[ Initialization ]]
RunService.Heartbeat:Connect(mainUpdateLoop) -- Connect the single main update loop
screenGui.Parent = playerGui
print("ESP Menu Script Loaded (v_camlock_snap_rmb). Menu visible. Press RightShift to toggle.")
