--[[ WARNING: This script contains a complex, script-generated graphical color picker.
     Due to its complexity, it may have bugs or performance issues.
     Creating such UIs visually in Studio is generally recommended. ]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")

local localPlayer = Players.LocalPlayer
if not localPlayer then Players.PlayerAdded:Wait(); localPlayer = Players.LocalPlayer end
local playerGui = localPlayer:WaitForChild("PlayerGui")
local currentCamera = workspace.CurrentCamera

-- Configuration & State
local featureStates = { ["ESP Box"] = false, ["Chams"] = false }
local featureColors = {
	["ESP Box"] = Color3.fromRGB(128, 0, 128), -- Purple Box
	["Chams"] = Color3.fromRGB(180, 0, 255) -- Purple Chams
}
local BOX_THICKNESS = 2; local BOX_SCALING_BASE = 3000; local BOX_MIN_SIZE = 30; local BOX_MAX_SIZE = 180
local isMenuVisible = true; local activeBillboards = {}; local activeChamsHighlights = {}
local currentEditingFeature = nil; local activeTab = "Visuals"

-- Menu UI Elements
local screenGui, menuFrame, colorPickerFrame = nil, nil, nil
local hexInput, colorPreview = nil, nil -- Hex Color Picker Elements
local tabContentFrames = {}; local tabButtons = {}

-- Action name for ContextActionService
local MENU_TOGGLE_ACTION = "ToggleEspMenuAction"

--[[ UI Creation ]]
screenGui = Instance.new("ScreenGui"); screenGui.Name = "EspMenuGUI"; screenGui.ResetOnSpawn = false; screenGui.IgnoreGuiInset = true; screenGui.DisplayOrder = 10

-- Main Menu Frame
menuFrame = Instance.new("Frame"); menuFrame.Name = "MenuFrame"; menuFrame.Size = UDim2.new(0, 250, 0, 200); menuFrame.Position = UDim2.new(0.5, -125, 0.5, -100); menuFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35); menuFrame.BorderColor3 = Color3.fromRGB(80, 80, 80); menuFrame.BorderSizePixel = 1; menuFrame.Active = true; menuFrame.Draggable = true; menuFrame.Visible = isMenuVisible; menuFrame.ClipsDescendants = true; menuFrame.Parent = screenGui; local mc = Instance.new("UICorner"); mc.CornerRadius = UDim.new(0, 4); mc.Parent = menuFrame
local titleBar = Instance.new("Frame"); titleBar.Name = "TitleBar"; titleBar.Size = UDim2.new(1, 0, 0, 25); titleBar.Position = UDim2.new(0, 0, 0, 0); titleBar.BackgroundColor3 = Color3.fromRGB(55, 55, 55); titleBar.BorderSizePixel = 0; titleBar.Parent = menuFrame; local tc = Instance.new("UICorner"); tc.CornerRadius = UDim.new(0, 4); tc.Parent = titleBar; local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1, -10, 1, 0); titleLabel.Position = UDim2.new(0, 5, 0, 0); titleLabel.BackgroundTransparency = 1; titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220); titleLabel.Font = Enum.Font.SourceSansSemibold; titleLabel.TextSize = 16; titleLabel.Text = "ESP Menu"; titleLabel.TextXAlignment = Enum.TextXAlignment.Left; titleLabel.Parent = titleBar
local tabButtonContainer = Instance.new("Frame"); tabButtonContainer.Name = "TabButtonContainer"; tabButtonContainer.Size = UDim2.new(1, 0, 0, 30); tabButtonContainer.Position = UDim2.new(0, 0, 0, 25); tabButtonContainer.BackgroundTransparency = 1; tabButtonContainer.BorderSizePixel = 0; tabButtonContainer.Parent = menuFrame; local tabListLayout = Instance.new("UIListLayout"); tabListLayout.FillDirection = Enum.FillDirection.Horizontal; tabListLayout.Padding = UDim.new(0, 5); tabListLayout.VerticalAlignment = Enum.VerticalAlignment.Center; tabListLayout.Parent = tabButtonContainer
local mainContentContainer = Instance.new("Frame"); mainContentContainer.Name = "MainContentContainer"; mainContentContainer.Size = UDim2.new(1, -10, 1, -60); mainContentContainer.Position = UDim2.new(0, 5, 0, 58); mainContentContainer.BackgroundTransparency = 1; mainContentContainer.BorderSizePixel = 0; mainContentContainer.ClipsDescendants = true; mainContentContainer.Parent = menuFrame
local function updateTabButtons() for name, button in pairs(tabButtons) do local isActive = (name == activeTab); button.BackgroundColor3 = isActive and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(50, 50, 50); button.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180) end end
local function createTab(tabName) local contentFrame = Instance.new("Frame"); contentFrame.Name = tabName .. "Content"; contentFrame.Size = UDim2.new(1, 0, 1, 0); contentFrame.Position = UDim2.new(0, 0, 0, 0); contentFrame.BackgroundTransparency = 1; contentFrame.BorderSizePixel = 0; contentFrame.Visible = (tabName == activeTab); contentFrame.Parent = mainContentContainer; tabContentFrames[tabName] = contentFrame; local listLayout = Instance.new("UIListLayout"); listLayout.Padding = UDim.new(0, 5); listLayout.SortOrder = Enum.SortOrder.LayoutOrder; listLayout.Parent = contentFrame; local tabButton = Instance.new("TextButton"); tabButton.Name = tabName .. "Tab"; tabButton.Size = UDim2.new(0, 80, 1, -4); tabButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50); tabButton.TextColor3 = Color3.fromRGB(180, 180, 180); tabButton.Font = Enum.Font.SourceSans; tabButton.TextSize = 14; tabButton.Text = tabName; tabButton.Parent = tabButtonContainer; local tbc = Instance.new("UICorner"); tbc.CornerRadius = UDim.new(0, 3); tbc.Parent = tabButton; tabButtons[tabName] = tabButton; tabButton.MouseButton1Click:Connect(function() if activeTab == tabName then return end; if tabContentFrames[activeTab] then tabContentFrames[activeTab].Visible = false end; contentFrame.Visible = true; activeTab = tabName; updateTabButtons() end); return contentFrame end
local visualsContent = createTab("Visuals"); local movementContent = createTab("Movement"); updateTabButtons()

-- Color Picker Frame (Hex Input Version)
colorPickerFrame = Instance.new("Frame"); colorPickerFrame.Name = "ColorPickerFrame"; colorPickerFrame.Size = UDim2.new(0, 200, 0, 100) -- Shorter frame
colorPickerFrame.Position = UDim2.new(0.5, -100, 0.5, -120); -- Reposition slightly
colorPickerFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45); colorPickerFrame.BorderColor3 = Color3.fromRGB(90, 90, 90); colorPickerFrame.BorderSizePixel = 1; colorPickerFrame.Visible = false; colorPickerFrame.ClipsDescendants = true; colorPickerFrame.Parent = screenGui; local pc = Instance.new("UICorner"); pc.CornerRadius = UDim.new(0, 4); pc.Parent = colorPickerFrame
local pickerTitle = Instance.new("TextLabel"); pickerTitle.Name = "PickerTitle"; pickerTitle.Size = UDim2.new(1, -10, 0, 20); pickerTitle.Position = UDim2.new(0, 5, 0, 3); pickerTitle.BackgroundTransparency = 1; pickerTitle.TextColor3 = Color3.fromRGB(200, 200, 200); pickerTitle.Font = Enum.Font.SourceSans; pickerTitle.TextSize = 14; pickerTitle.Text = "Edit Color"; pickerTitle.TextXAlignment = Enum.TextXAlignment.Left; pickerTitle.Parent = colorPickerFrame

-- Hex Input Row
local hexLabel = Instance.new("TextLabel"); hexLabel.Name = "HexLabel"; hexLabel.Size = UDim2.new(0.25, 0, 0, 25); hexLabel.Position = UDim2.new(0, 5, 0, 30); hexLabel.BackgroundTransparency = 1; hexLabel.TextColor3 = Color3.fromRGB(180, 180, 180); hexLabel.Font = Enum.Font.SourceSans; hexLabel.TextSize = 14; hexLabel.Text = "Hex:"; hexLabel.TextXAlignment = Enum.TextXAlignment.Right; hexLabel.Parent = colorPickerFrame
hexInput = Instance.new("TextBox"); hexInput.Name = "HexInput"; hexInput.Size = UDim2.new(0.4, 0, 0, 25); hexInput.Position = UDim2.new(0.25, 10, 0, 30); hexInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); hexInput.TextColor3 = Color3.fromRGB(220, 220, 220); hexInput.Font = Enum.Font.SourceSans; hexInput.TextSize = 14; hexInput.ClearTextOnFocus = false; hexInput.Text = "FFFFFF"; hexInput.Parent = colorPickerFrame; local hic = Instance.new("UICorner"); hic.CornerRadius = UDim.new(0, 3); hic.Parent = hexInput

-- Preview (Positioned next to hex input)
colorPreview = Instance.new("Frame"); colorPreview.Name = "ColorPreview"; colorPreview.Size = UDim2.new(0.25, -15, 0, 25); colorPreview.Position = UDim2.new(0.7, 10, 0, 30); colorPreview.BackgroundColor3 = Color3.fromRGB(255, 255, 255); colorPreview.BorderSizePixel = 1; colorPreview.BorderColor3 = Color3.fromRGB(100,100,100); colorPreview.Parent = colorPickerFrame; local prvC = Instance.new("UICorner"); prvC.CornerRadius = UDim.new(0, 3); prvC.Parent=colorPreview

-- Apply/Close Buttons (Positioned at bottom)
applyButton = Instance.new("TextButton"); applyButton.Name = "ApplyButton"; applyButton.Size = UDim2.new(0.45, -5, 0, 25); applyButton.Position = UDim2.new(0, 5, 1, -30); applyButton.BackgroundColor3 = Color3.fromRGB(80, 120, 80); applyButton.TextColor3 = Color3.fromRGB(220, 220, 220); applyButton.Font = Enum.Font.SourceSansSemibold; applyButton.TextSize = 14; applyButton.Text = "Apply"; applyButton.Parent = colorPickerFrame; local ac = Instance.new("UICorner"); ac.CornerRadius = UDim.new(0, 3); ac.Parent = applyButton
closeButton = Instance.new("TextButton"); closeButton.Name = "CloseButton"; closeButton.Size = UDim2.new(0.45, -5, 0, 25); closeButton.Position = UDim2.new(0.5, 5, 1, -30); closeButton.BackgroundColor3 = Color3.fromRGB(120, 80, 80); closeButton.TextColor3 = Color3.fromRGB(220, 220, 220); closeButton.Font = Enum.Font.SourceSansSemibold; closeButton.TextSize = 14; closeButton.Text = "Close"; closeButton.Parent = colorPickerFrame; local cc = Instance.new("UICorner"); cc.CornerRadius = UDim.new(0, 3); cc.Parent = closeButton

-- Function to validate and convert hex string
local function parseHexColor(hex)
	hex = string.gsub(hex or "", "#", "") -- Remove leading # if present
	if string.len(hex) ~= 6 then return nil end -- Must be 6 chars
	if not string.match(hex, "^[0-9a-fA-F]+$") then return nil end -- Must be hex chars

	local success, color = pcall(Color3.fromHex, hex)
	if success then
		return color
	else
		return nil -- fromHex failed
	end
end

-- Function to update color preview from Hex TextBox
local function updatePreview()
	local color = parseHexColor(hexInput.Text)
	if color then
		colorPreview.BackgroundColor3 = color
		hexInput.BorderColor3 = Color3.fromRGB(60,60,60) -- Reset border on valid
	else
		colorPreview.BackgroundColor3 = Color3.fromRGB(80, 80, 80) -- Gray preview on error
		hexInput.BorderColor3 = Color3.fromRGB(255,0,0) -- Red border on invalid
	end
end
hexInput:GetPropertyChangedSignal("Text"):Connect(updatePreview)
hexInput.FocusLost:Connect(updatePreview) -- Update preview when focus lost too

-- Function to open color picker (Sets Hex TextBox)
local function openColorPicker(featureName)
	currentEditingFeature = featureName
	local currentColor = featureColors[featureName]
	if currentColor then
		hexInput.Text = currentColor:ToHex() -- Set hex value (no #)
		updatePreview() -- Update preview with initial color
		pickerTitle.Text = "Edit "..featureName.." Color"; colorPickerFrame.Visible = true
	end
end

-- Apply button logic (Uses Hex TextBox)
applyButton.MouseButton1Click:Connect(function()
	if currentEditingFeature then
		local newColor = parseHexColor(hexInput.Text)
		if newColor then
			featureColors[currentEditingFeature] = newColor
			-- print(currentEditingFeature .. " color updated to:", featureColors[currentEditingFeature]) -- Debug
			colorPickerFrame.Visible = false; currentEditingFeature = nil
		else
			-- Optional: Indicate error, maybe shake the textbox or keep border red
			print("Invalid Hex code entered.")
		end
	end
end)

-- Close button logic
closeButton.MouseButton1Click:Connect(function() colorPickerFrame.Visible = false; currentEditingFeature = nil end)

-- Helper function to create a feature toggle button row
local function createFeatureToggle(featureName, order, parentFrame)
	local rowFrame = Instance.new("Frame"); rowFrame.Name = featureName .. "RowFrame"; rowFrame.Size = UDim2.new(1, 0, 0, 30); rowFrame.BackgroundTransparency = 1; rowFrame.LayoutOrder = order; rowFrame.Parent = parentFrame
	local featureButton = Instance.new("TextButton"); featureButton.Name = featureName .. "Button"; featureButton.Size = UDim2.new(1, -35, 1, 0); featureButton.Position = UDim2.new(0, 0, 0, 0); featureButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); featureButton.TextColor3 = Color3.fromRGB(220, 220, 220); featureButton.Font = Enum.Font.SourceSans; featureButton.TextSize = 14; featureButton.Text = featureName; featureButton.Parent = rowFrame; local fc = Instance.new("UICorner"); fc.CornerRadius = UDim.new(0, 3); fc.Parent = featureButton
	local gearButton = Instance.new("TextButton"); gearButton.Name = "GearButton"; gearButton.Size = UDim2.new(0, 25, 1, 0); gearButton.Position = UDim2.new(1, -30, 0, 0); gearButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70); gearButton.TextColor3 = Color3.fromRGB(200, 200, 200); gearButton.Font = Enum.Font.SourceSansSemibold; gearButton.TextSize = 16; gearButton.Text = "⚙️"; gearButton.Parent = rowFrame; local gc = Instance.new("UICorner"); gc.CornerRadius = UDim.new(0, 3); gc.Parent = gearButton
	local function updateAppearance() local isActive = featureStates[featureName]; featureButton.BackgroundColor3 = isActive and Color3.fromRGB(90, 140, 90) or Color3.fromRGB(60, 60, 60); featureButton.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(220, 220, 220) end
	featureButton.MouseButton1Click:Connect(function() featureStates[featureName] = not featureStates[featureName]; updateAppearance() end)
	gearButton.MouseButton1Click:Connect(function() openColorPicker(featureName) end)
	updateAppearance()
end

-- Create the feature toggles within the 'Visuals' content frame
createFeatureToggle("ESP Box", 1, visualsContent)
createFeatureToggle("Chams", 2, visualsContent)

--[[ Core Logic (ESP/Chams Update) - Unchanged ]]
local function createBoxFrames(billboard) local boxColor = featureColors["ESP Box"]; local boxContainer = Instance.new("Frame"); boxContainer.Name = "BoxContainer"; boxContainer.BackgroundTransparency = 1; boxContainer.Size = UDim2.new(1, 0, 1, 0); boxContainer.Parent = billboard; local top = Instance.new("Frame"); top.Name = "Top"; top.BackgroundColor3 = boxColor; top.BorderSizePixel = 0; top.Size = UDim2.new(1, 0, 0, BOX_THICKNESS); top.Position = UDim2.new(0, 0, 0, 0); top.Parent = boxContainer; local bottom = Instance.new("Frame"); bottom.Name = "Bottom"; bottom.BackgroundColor3 = boxColor; bottom.BorderSizePixel = 0; bottom.Size = UDim2.new(1, 0, 0, BOX_THICKNESS); bottom.Position = UDim2.new(0, 0, 1, -BOX_THICKNESS); bottom.Parent = boxContainer; local left = Instance.new("Frame"); left.Name = "Left"; left.BackgroundColor3 = boxColor; left.BorderSizePixel = 0; left.Size = UDim2.new(0, BOX_THICKNESS, 1, 0); left.Position = UDim2.new(0, 0, 0, 0); left.Parent = boxContainer; local right = Instance.new("Frame"); right.Name = "Right"; right.BackgroundColor3 = boxColor; right.BorderSizePixel = 0; right.Size = UDim2.new(0, BOX_THICKNESS, 1, 0); right.Position = UDim2.new(1, -BOX_THICKNESS, 0, 0); right.Parent = boxContainer; return boxContainer end
local function updateEspAndChams() if not currentCamera then currentCamera = workspace.CurrentCamera return end; local currentPlayers = Players:GetPlayers(); local playersToUpdate = {}; for _, player in ipairs(currentPlayers) do if player == localPlayer then continue end; local character = player.Character; local humanoid = character and character:FindFirstChildOfClass("Humanoid"); local hrp = humanoid and humanoid.RootPart; if character and character.Parent == workspace and humanoid and humanoid.Health > 0 and hrp then playersToUpdate[player] = true; if featureStates["ESP Box"] then local billboard = activeBillboards[player]; local boxColor = featureColors["ESP Box"]; if not billboard or not billboard.Parent then billboard = Instance.new("BillboardGui"); billboard.Name = "EspBillboard"; billboard.AlwaysOnTop = true; billboard.Size = UDim2.new(0, 100, 0, 150); billboard.Adornee = hrp; billboard.LightInfluence = 0; billboard.ResetOnSpawn = false; createBoxFrames(billboard); billboard.Parent = playerGui; activeBillboards[player] = billboard end; local distance = (hrp.Position - currentCamera.CFrame.Position).Magnitude; local scaleFactor = math.clamp(BOX_SCALING_BASE / math.max(distance, 0.1), BOX_MIN_SIZE, BOX_MAX_SIZE); billboard.Size = UDim2.new(0, scaleFactor, 0, scaleFactor * 1.5); billboard.Enabled = true; if billboard.BoxContainer then for _, frame in ipairs(billboard.BoxContainer:GetChildren()) do if frame:IsA("Frame") then frame.BackgroundColor3 = boxColor end end end else if activeBillboards[player] then activeBillboards[player]:Destroy(); activeBillboards[player] = nil end end; if featureStates["Chams"] then local chamsHighlight = activeChamsHighlights[player]; local chamsColor = featureColors["Chams"]; if not chamsHighlight or not chamsHighlight.Parent then chamsHighlight = Instance.new("Highlight"); chamsHighlight.Name = "ChamsHighlight"; chamsHighlight.Adornee = character; chamsHighlight.FillColor = chamsColor; chamsHighlight.FillTransparency = 0; chamsHighlight.OutlineTransparency = 1; chamsHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; chamsHighlight.Enabled = true; chamsHighlight.Parent = character; activeChamsHighlights[player] = chamsHighlight elseif chamsHighlight.Adornee ~= character then chamsHighlight.Adornee = character; chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor else chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor end else if activeChamsHighlights[player] then activeChamsHighlights[player]:Destroy(); activeChamsHighlights[player] = nil end end else if activeBillboards[player] then activeBillboards[player]:Destroy(); activeBillboards[player] = nil end; if activeChamsHighlights[player] then activeChamsHighlights[player]:Destroy(); activeChamsHighlights[player] = nil end end end; for player, billboard in pairs(activeBillboards) do if not playersToUpdate[player] then billboard:Destroy(); activeBillboards[player] = nil end end; for player, chamsHighlight in pairs(activeChamsHighlights) do if not playersToUpdate[player] then chamsHighlight:Destroy(); activeChamsHighlights[player] = nil end end end

--[[ Input Handling using ContextActionService ]]
local function handleMenuToggle(actionName, inputState, inputObject) if inputState == Enum.UserInputState.Begin then isMenuVisible = not isMenuVisible; if menuFrame then menuFrame.Visible = isMenuVisible end; if not isMenuVisible and colorPickerFrame then colorPickerFrame.Visible = false; currentEditingFeature = nil end end; return Enum.ContextActionResult.Pass end
ContextActionService:BindAction(MENU_TOGGLE_ACTION, handleMenuToggle, false, Enum.KeyCode.RightShift)

--[[ Initialization ]]
RunService.RenderStepped:Connect(updateEspAndChams)
screenGui.Parent = playerGui
print("ESP Menu Script Loaded (v_hex_picker). Menu visible. Press RightShift to toggle.")
