--[[ WARNING: This script contains complex UI elements generated by script.
     Consider using Studio for more complex UI development. ]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")

local localPlayer = Players.LocalPlayer
if not localPlayer then Players.PlayerAdded:Wait(); localPlayer = Players.LocalPlayer end
local playerGui = localPlayer:WaitForChild("PlayerGui")
local currentCamera = workspace.CurrentCamera

-- Configuration & State
local featureStates = { ["ESP Box"] = false, ["Chams"] = false, ["Fly"] = false }
local featureColors = { ["ESP Box"] = Color3.fromRGB(128, 0, 128), ["Chams"] = Color3.fromRGB(180, 0, 255) }
local BOX_THICKNESS = 2; local BOX_SCALING_BASE = 3000; local BOX_MIN_SIZE = 30; local BOX_MAX_SIZE = 180
local flySpeed = 50
local flyKeybind = Enum.KeyCode.F
local isMenuVisible = true; local activeBillboards = {}; local activeChamsHighlights = {}
local currentEditingFeature = nil; local activeTab = "Visuals"
local isFlying = false -- State for whether flight mechanics are active (toggled by keybind)
local isChangingFlyKeybind = false
local flyVelocityInstance = nil
local flyGyroInstance = nil
local flightControlConnection = nil

-- Menu UI Elements
local screenGui, menuFrame, colorPickerFrame = nil, nil, nil
local hexInput, colorPreview = nil, nil
local flySpeedInput = nil
local flyKeybindButton = nil
local tabContentFrames = {}; local tabButtons = {}

-- Action name for ContextActionService
local MENU_TOGGLE_ACTION = "ToggleEspMenuAction"

--[[ UI Creation ]]
screenGui = Instance.new("ScreenGui"); screenGui.Name = "EspMenuGUI"; screenGui.ResetOnSpawn = false; screenGui.IgnoreGuiInset = true; screenGui.DisplayOrder = 10
menuFrame = Instance.new("Frame"); menuFrame.Name = "MenuFrame"; menuFrame.Size = UDim2.new(0, 250, 0, 220); menuFrame.Position = UDim2.new(0.5, -125, 0.5, -110); menuFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35); menuFrame.BorderColor3 = Color3.fromRGB(80, 80, 80); menuFrame.BorderSizePixel = 1; menuFrame.Active = true; menuFrame.Draggable = true; menuFrame.Visible = isMenuVisible; menuFrame.ClipsDescendants = true; menuFrame.Parent = screenGui; local mc = Instance.new("UICorner"); mc.CornerRadius = UDim.new(0, 4); mc.Parent = menuFrame
local titleBar = Instance.new("Frame"); titleBar.Name = "TitleBar"; titleBar.Size = UDim2.new(1, 0, 0, 25); titleBar.Position = UDim2.new(0, 0, 0, 0); titleBar.BackgroundColor3 = Color3.fromRGB(55, 55, 55); titleBar.BorderSizePixel = 0; titleBar.Parent = menuFrame; local tc = Instance.new("UICorner"); tc.CornerRadius = UDim.new(0, 4); tc.Parent = titleBar; local titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1, -10, 1, 0); titleLabel.Position = UDim2.new(0, 5, 0, 0); titleLabel.BackgroundTransparency = 1; titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220); titleLabel.Font = Enum.Font.SourceSansSemibold; titleLabel.TextSize = 16; titleLabel.Text = "ESP Menu"; titleLabel.TextXAlignment = Enum.TextXAlignment.Left; titleLabel.Parent = titleBar
local tabButtonContainer = Instance.new("Frame"); tabButtonContainer.Name = "TabButtonContainer"; tabButtonContainer.Size = UDim2.new(1, 0, 0, 30); tabButtonContainer.Position = UDim2.new(0, 0, 0, 25); tabButtonContainer.BackgroundTransparency = 1; tabButtonContainer.BorderSizePixel = 0; tabButtonContainer.Parent = menuFrame; local tabListLayout = Instance.new("UIListLayout"); tabListLayout.FillDirection = Enum.FillDirection.Horizontal; tabListLayout.Padding = UDim.new(0, 5); tabListLayout.VerticalAlignment = Enum.VerticalAlignment.Center; tabListLayout.Parent = tabButtonContainer
local mainContentContainer = Instance.new("Frame"); mainContentContainer.Name = "MainContentContainer"; mainContentContainer.Size = UDim2.new(1, -10, 1, -60); mainContentContainer.Position = UDim2.new(0, 5, 0, 58); mainContentContainer.BackgroundTransparency = 1; mainContentContainer.BorderSizePixel = 0; mainContentContainer.ClipsDescendants = true; mainContentContainer.Parent = menuFrame
local function updateTabButtons() for name, button in pairs(tabButtons) do local isActive = (name == activeTab); button.BackgroundColor3 = isActive and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(50, 50, 50); button.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180) end end
local function createTab(tabName) local contentFrame = Instance.new("Frame"); contentFrame.Name = tabName .. "Content"; contentFrame.Size = UDim2.new(1, 0, 1, 0); contentFrame.Position = UDim2.new(0, 0, 0, 0); contentFrame.BackgroundTransparency = 1; contentFrame.BorderSizePixel = 0; contentFrame.Visible = (tabName == activeTab); contentFrame.Parent = mainContentContainer; tabContentFrames[tabName] = contentFrame; local listLayout = Instance.new("UIListLayout"); listLayout.Padding = UDim.new(0, 5); listLayout.SortOrder = Enum.SortOrder.LayoutOrder; listLayout.Parent = contentFrame; local tabButton = Instance.new("TextButton"); tabButton.Name = tabName .. "Tab"; tabButton.Size = UDim2.new(0, 80, 1, -4); tabButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50); tabButton.TextColor3 = Color3.fromRGB(180, 180, 180); tabButton.Font = Enum.Font.SourceSans; tabButton.TextSize = 14; tabButton.Text = tabName; tabButton.Parent = tabButtonContainer; local tbc = Instance.new("UICorner"); tbc.CornerRadius = UDim.new(0, 3); tbc.Parent = tabButton; tabButtons[tabName] = tabButton; tabButton.MouseButton1Click:Connect(function() if activeTab == tabName then return end; if tabContentFrames[activeTab] then tabContentFrames[activeTab].Visible = false end; contentFrame.Visible = true; activeTab = tabName; updateTabButtons() end); return contentFrame end
local visualsContent = createTab("Visuals"); local movementContent = createTab("Movement"); updateTabButtons()

-- Color Picker Frame (Hex Input Version)
colorPickerFrame = Instance.new("Frame"); colorPickerFrame.Name = "ColorPickerFrame"; colorPickerFrame.Size = UDim2.new(0, 200, 0, 100); colorPickerFrame.Position = UDim2.new(0.5, -100, 0.5, -120); colorPickerFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45); colorPickerFrame.BorderColor3 = Color3.fromRGB(90, 90, 90); colorPickerFrame.BorderSizePixel = 1; colorPickerFrame.Visible = false; colorPickerFrame.ClipsDescendants = true; colorPickerFrame.Parent = screenGui; local pc = Instance.new("UICorner"); pc.CornerRadius = UDim.new(0, 4); pc.Parent = colorPickerFrame
local pickerTitle = Instance.new("TextLabel"); pickerTitle.Name = "PickerTitle"; pickerTitle.Size = UDim2.new(1, -10, 0, 20); pickerTitle.Position = UDim2.new(0, 5, 0, 3); pickerTitle.BackgroundTransparency = 1; pickerTitle.TextColor3 = Color3.fromRGB(200, 200, 200); pickerTitle.Font = Enum.Font.SourceSans; pickerTitle.TextSize = 14; pickerTitle.Text = "Edit Color"; pickerTitle.TextXAlignment = Enum.TextXAlignment.Left; pickerTitle.Parent = colorPickerFrame
local hexLabel = Instance.new("TextLabel"); hexLabel.Name = "HexLabel"; hexLabel.Size = UDim2.new(0.25, 0, 0, 25); hexLabel.Position = UDim2.new(0, 5, 0, 30); hexLabel.BackgroundTransparency = 1; hexLabel.TextColor3 = Color3.fromRGB(180, 180, 180); hexLabel.Font = Enum.Font.SourceSans; hexLabel.TextSize = 14; hexLabel.Text = "Hex:"; hexLabel.TextXAlignment = Enum.TextXAlignment.Right; hexLabel.Parent = colorPickerFrame
hexInput = Instance.new("TextBox"); hexInput.Name = "HexInput"; hexInput.Size = UDim2.new(0.4, 0, 0, 25); hexInput.Position = UDim2.new(0.25, 10, 0, 30); hexInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); hexInput.TextColor3 = Color3.fromRGB(220, 220, 220); hexInput.Font = Enum.Font.SourceSans; hexInput.TextSize = 14; hexInput.ClearTextOnFocus = false; hexInput.Text = "FFFFFF"; hexInput.Parent = colorPickerFrame; local hic = Instance.new("UICorner"); hic.CornerRadius = UDim.new(0, 3); hic.Parent = hexInput
colorPreview = Instance.new("Frame"); colorPreview.Name = "ColorPreview"; colorPreview.Size = UDim2.new(0.25, -15, 0, 25); colorPreview.Position = UDim2.new(0.7, 10, 0, 30); colorPreview.BackgroundColor3 = Color3.fromRGB(255, 255, 255); colorPreview.BorderSizePixel = 1; colorPreview.BorderColor3 = Color3.fromRGB(100,100,100); colorPreview.Parent = colorPickerFrame; local prvC = Instance.new("UICorner"); prvC.CornerRadius = UDim.new(0, 3); prvC.Parent=colorPreview
applyButton = Instance.new("TextButton"); applyButton.Name = "ApplyButton"; applyButton.Size = UDim2.new(0.45, -5, 0, 25); applyButton.Position = UDim2.new(0, 5, 1, -30); applyButton.BackgroundColor3 = Color3.fromRGB(80, 120, 80); applyButton.TextColor3 = Color3.fromRGB(220, 220, 220); applyButton.Font = Enum.Font.SourceSansSemibold; applyButton.TextSize = 14; applyButton.Text = "Apply"; applyButton.Parent = colorPickerFrame; local ac = Instance.new("UICorner"); ac.CornerRadius = UDim.new(0, 3); ac.Parent = applyButton
closeButton = Instance.new("TextButton"); closeButton.Name = "CloseButton"; closeButton.Size = UDim2.new(0.45, -5, 0, 25); closeButton.Position = UDim2.new(0.5, 5, 1, -30); closeButton.BackgroundColor3 = Color3.fromRGB(120, 80, 80); closeButton.TextColor3 = Color3.fromRGB(220, 220, 220); closeButton.Font = Enum.Font.SourceSansSemibold; closeButton.TextSize = 14; closeButton.Text = "Close"; closeButton.Parent = colorPickerFrame; local cc = Instance.new("UICorner"); cc.CornerRadius = UDim.new(0, 3); cc.Parent = closeButton
local function parseHexColor(hex) hex = string.gsub(hex or "", "#", ""); if string.len(hex) ~= 6 then return nil end; if not string.match(hex, "^[0-9a-fA-F]+$") then return nil end; local s, c = pcall(Color3.fromHex, hex); if s then return c else return nil end end
local function updatePreview() local c = parseHexColor(hexInput.Text); if c then colorPreview.BackgroundColor3 = c; hexInput.BorderColor3 = Color3.fromRGB(60,60,60) else colorPreview.BackgroundColor3 = Color3.fromRGB(80, 80, 80); hexInput.BorderColor3 = Color3.fromRGB(255,0,0) end end; hexInput:GetPropertyChangedSignal("Text"):Connect(updatePreview); hexInput.FocusLost:Connect(updatePreview)
local function openColorPicker(fName) currentEditingFeature = fName; local cC = featureColors[fName]; if cC then hexInput.Text = cC:ToHex(); updatePreview(); pickerTitle.Text = "Edit "..fName.." Color"; colorPickerFrame.Visible = true end end
applyButton.MouseButton1Click:Connect(function() if currentEditingFeature then local nC = parseHexColor(hexInput.Text); if nC then featureColors[currentEditingFeature] = nC; colorPickerFrame.Visible = false; currentEditingFeature = nil else print("Invalid Hex code.") end end end)
closeButton.MouseButton1Click:Connect(function() colorPickerFrame.Visible = false; currentEditingFeature = nil end)

-- Helper function to create a feature toggle button row
local function createFeatureToggle(featureName, order, parentFrame, showGear)
	local rowFrame = Instance.new("Frame"); rowFrame.Name = featureName .. "RowFrame"; rowFrame.Size = UDim2.new(1, 0, 0, 30); rowFrame.BackgroundTransparency = 1; rowFrame.LayoutOrder = order; rowFrame.Parent = parentFrame
	local gearWidth = showGear and 35 or 0
	local featureButton = Instance.new("TextButton"); featureButton.Name = featureName .. "Button"; featureButton.Size = UDim2.new(1, -gearWidth, 1, 0); featureButton.Position = UDim2.new(0, 0, 0, 0); featureButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); featureButton.TextColor3 = Color3.fromRGB(220, 220, 220); featureButton.Font = Enum.Font.SourceSans; featureButton.TextSize = 14; featureButton.Text = featureName; featureButton.Parent = rowFrame; local fc = Instance.new("UICorner"); fc.CornerRadius = UDim.new(0, 3); fc.Parent = featureButton
	local gearButton = nil
	if showGear then gearButton = Instance.new("TextButton"); gearButton.Name = "GearButton"; gearButton.Size = UDim2.new(0, 25, 1, 0); gearButton.Position = UDim2.new(1, -30, 0, 0); gearButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70); gearButton.TextColor3 = Color3.fromRGB(200, 200, 200); gearButton.Font = Enum.Font.SourceSansSemibold; gearButton.TextSize = 16; gearButton.Text = "⚙️"; gearButton.Parent = rowFrame; local gc = Instance.new("UICorner"); gc.CornerRadius = UDim.new(0, 3); gc.Parent = gearButton; gearButton.MouseButton1Click:Connect(function() openColorPicker(featureName) end) end
	local function updateAppearance() local isActive = featureStates[featureName]; featureButton.BackgroundColor3 = isActive and Color3.fromRGB(90, 140, 90) or Color3.fromRGB(60, 60, 60); featureButton.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(220, 220, 220) end
	featureButton.MouseButton1Click:Connect(function()
		featureStates[featureName] = not featureStates[featureName]
		updateAppearance()
		-- Special handling for Fly toggle OFF: stop flying if active
		if featureName == "Fly" and not featureStates["Fly"] and isFlying then
			stopFlying()
		end
	end)
	updateAppearance()
end

-- Create Visuals Tab Features
createFeatureToggle("ESP Box", 1, visualsContent, true)
createFeatureToggle("Chams", 2, visualsContent, true)

-- Create Movement Tab Features
createFeatureToggle("Fly", 1, movementContent, false) -- Fly toggle itself

-- Fly Speed Setting
local speedFrame = Instance.new("Frame"); speedFrame.Name = "FlySpeedFrame"; speedFrame.Size = UDim2.new(1, 0, 0, 25); speedFrame.BackgroundTransparency = 1; speedFrame.LayoutOrder = 2; speedFrame.Parent = movementContent
local speedLabel = Instance.new("TextLabel"); speedLabel.Name = "Label"; speedLabel.Size = UDim2.new(0.5, -5, 1, 0); speedLabel.Position = UDim2.new(0, 0, 0, 0); speedLabel.BackgroundTransparency = 1; speedLabel.TextColor3 = Color3.fromRGB(200, 200, 200); speedLabel.Font = Enum.Font.SourceSans; speedLabel.TextSize = 14; speedLabel.Text = "Fly Speed:"; speedLabel.TextXAlignment = Enum.TextXAlignment.Left; speedLabel.Parent = speedFrame
flySpeedInput = Instance.new("TextBox"); flySpeedInput.Name = "SpeedInput"; flySpeedInput.Size = UDim2.new(0.5, 0, 1, 0); flySpeedInput.Position = UDim2.new(0.5, 0, 0, 0); flySpeedInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60); flySpeedInput.TextColor3 = Color3.fromRGB(220, 220, 220); flySpeedInput.Font = Enum.Font.SourceSans; flySpeedInput.TextSize = 14; flySpeedInput.ClearTextOnFocus = false; flySpeedInput.Text = tostring(flySpeed); flySpeedInput.Parent = speedFrame; local sic = Instance.new("UICorner"); sic.CornerRadius = UDim.new(0, 3); sic.Parent = flySpeedInput
flySpeedInput.FocusLost:Connect(function(enterPressed) if enterPressed or true then local num = tonumber(flySpeedInput.Text); if num and num > 0 then flySpeed = num; flySpeedInput.Text = tostring(flySpeed) else flySpeedInput.Text = tostring(flySpeed) end end end)

-- Fly Keybind Setting
local keybindFrame = Instance.new("Frame"); keybindFrame.Name = "FlyKeybindFrame"; keybindFrame.Size = UDim2.new(1, 0, 0, 25); keybindFrame.BackgroundTransparency = 1; keybindFrame.LayoutOrder = 3; keybindFrame.Parent = movementContent
local keybindLabel = Instance.new("TextLabel"); keybindLabel.Name = "Label"; keybindLabel.Size = UDim2.new(0.5, -5, 1, 0); keybindLabel.Position = UDim2.new(0, 0, 0, 0); keybindLabel.BackgroundTransparency = 1; keybindLabel.TextColor3 = Color3.fromRGB(200, 200, 200); keybindLabel.Font = Enum.Font.SourceSans; keybindLabel.TextSize = 14; keybindLabel.Text = "Fly Keybind:"; keybindLabel.TextXAlignment = Enum.TextXAlignment.Left; keybindLabel.Parent = keybindFrame
flyKeybindButton = Instance.new("TextButton"); flyKeybindButton.Name = "KeybindButton"; flyKeybindButton.Size = UDim2.new(0.5, 0, 1, 0); flyKeybindButton.Position = UDim2.new(0.5, 0, 0, 0); flyKeybindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60); flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220); flyKeybindButton.Font = Enum.Font.SourceSans; flyKeybindButton.TextSize = 14; flyKeybindButton.Text = flyKeybind.Name; flyKeybindButton.Parent = keybindFrame; local kbc = Instance.new("UICorner"); kbc.CornerRadius = UDim.new(0, 3); kbc.Parent = flyKeybindButton
flyKeybindButton.MouseButton1Click:Connect(function() if isChangingFlyKeybind then return end; isChangingFlyKeybind = true; flyKeybindButton.Text = "[Press Key]"; flyKeybindButton.TextColor3 = Color3.fromRGB(255,255,0) end)

--[[ Flight Logic ]]
local function startFlying()
	local char = localPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart"); local humanoid = char and char:FindFirstChildOfClass("Humanoid")
	if not hrp or not humanoid or isFlying then return end -- Already flying or no character
	isFlying = true
	print("Flight Started") -- Debug

	if flyVelocityInstance and flyVelocityInstance.Parent then flyVelocityInstance:Destroy() end
	if flyGyroInstance and flyGyroInstance.Parent then flyGyroInstance:Destroy() end

	flyVelocityInstance = Instance.new("BodyVelocity"); flyVelocityInstance.Name = "FlyVelocity"; flyVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge); flyVelocityInstance.Velocity = Vector3.zero; flyVelocityInstance.Parent = hrp
	flyGyroInstance = Instance.new("BodyGyro"); flyGyroInstance.Name = "FlyGyro"; flyGyroInstance.MaxTorque = Vector3.new(400000, 400000, 400000) * 50; flyGyroInstance.P = 5000; flyGyroInstance.D = 500; flyGyroInstance.CFrame = hrp.CFrame; flyGyroInstance.Parent = hrp

	if flightControlConnection then flightControlConnection:Disconnect() end
	flightControlConnection = RunService.Heartbeat:Connect(controlFlight)
end

local function stopFlying()
	if not isFlying then return end -- Only stop if currently flying
	isFlying = false
	print("Flight Stopped") -- Debug
	if flyVelocityInstance then flyVelocityInstance:Destroy(); flyVelocityInstance = nil end
	if flyGyroInstance then flyGyroInstance:Destroy(); flyGyroInstance = nil end
	if flightControlConnection then flightControlConnection:Disconnect(); flightControlConnection = nil end
end

function controlFlight(dt)
	-- Stop flight if the menu toggle was turned off
	if not featureStates["Fly"] then stopFlying(); return end
	-- Stop flight if character or HRP is gone
	local char = localPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not isFlying or not flyVelocityInstance or not flyGyroInstance or not hrp then stopFlying(); return end

	local moveVector = Vector3.zero
	if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector += Vector3.new(0,0,-1) end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector += Vector3.new(0,0,1) end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector += Vector3.new(-1,0,0) end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector += Vector3.new(1,0,0) end
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVector += Vector3.new(0,1,0) end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.C) then moveVector += Vector3.new(0,-1,0) end

	local finalVelocity = Vector3.zero
	if moveVector.Magnitude > 0 then
		moveVector = moveVector.Unit
		local cameraDirection = currentCamera.CFrame.LookVector; local cameraUp = currentCamera.CFrame.UpVector; local cameraRight = currentCamera.CFrame.RightVector
		local direction = (cameraRight * moveVector.X + cameraUp * moveVector.Y + cameraDirection * moveVector.Z)
		finalVelocity = direction.Unit * flySpeed
	end
	flyVelocityInstance.Velocity = finalVelocity
	flyGyroInstance.CFrame = CFrame.new(hrp.Position, hrp.Position + currentCamera.CFrame.LookVector)
end

-- Stop flying if character dies/resets
local function onCharacterAdded(char)
	stopFlying()
	local humanoid = char:WaitForChild("Humanoid")
	humanoid.Died:Connect(stopFlying)
end
localPlayer.CharacterAdded:Connect(onCharacterAdded)
if localPlayer.Character then onCharacterAdded(localPlayer.Character) end -- Handle existing character

--[[ Core ESP/Chams Update Logic - Unchanged ]]
local function createBoxFrames(billboard) local boxColor = featureColors["ESP Box"]; local boxContainer = Instance.new("Frame"); boxContainer.Name = "BoxContainer"; boxContainer.BackgroundTransparency = 1; boxContainer.Size = UDim2.new(1, 0, 1, 0); boxContainer.Parent = billboard; local top = Instance.new("Frame"); top.Name = "Top"; top.BackgroundColor3 = boxColor; top.BorderSizePixel = 0; top.Size = UDim2.new(1, 0, 0, BOX_THICKNESS); top.Position = UDim2.new(0, 0, 0, 0); top.Parent = boxContainer; local bottom = Instance.new("Frame"); bottom.Name = "Bottom"; bottom.BackgroundColor3 = boxColor; bottom.BorderSizePixel = 0; bottom.Size = UDim2.new(1, 0, 0, BOX_THICKNESS); bottom.Position = UDim2.new(0, 0, 1, -BOX_THICKNESS); bottom.Parent = boxContainer; local left = Instance.new("Frame"); left.Name = "Left"; left.BackgroundColor3 = boxColor; left.BorderSizePixel = 0; left.Size = UDim2.new(0, BOX_THICKNESS, 1, 0); left.Position = UDim2.new(0, 0, 0, 0); left.Parent = boxContainer; local right = Instance.new("Frame"); right.Name = "Right"; right.BackgroundColor3 = boxColor; right.BorderSizePixel = 0; right.Size = UDim2.new(0, BOX_THICKNESS, 1, 0); right.Position = UDim2.new(1, -BOX_THICKNESS, 0, 0); right.Parent = boxContainer; return boxContainer end
local function updateEspAndChams() if not currentCamera then currentCamera = workspace.CurrentCamera return end; local currentPlayers = Players:GetPlayers(); local playersToUpdate = {}; for _, player in ipairs(currentPlayers) do if player == localPlayer then continue end; local character = player.Character; local humanoid = character and character:FindFirstChildOfClass("Humanoid"); local hrp = humanoid and humanoid.RootPart; if character and character.Parent == workspace and humanoid and humanoid.Health > 0 and hrp then playersToUpdate[player] = true; if featureStates["ESP Box"] then local billboard = activeBillboards[player]; local boxColor = featureColors["ESP Box"]; if not billboard or not billboard.Parent then billboard = Instance.new("BillboardGui"); billboard.Name = "EspBillboard"; billboard.AlwaysOnTop = true; billboard.Size = UDim2.new(0, 100, 0, 150); billboard.Adornee = hrp; billboard.LightInfluence = 0; billboard.ResetOnSpawn = false; createBoxFrames(billboard); billboard.Parent = playerGui; activeBillboards[player] = billboard end; local distance = (hrp.Position - currentCamera.CFrame.Position).Magnitude; local scaleFactor = math.clamp(BOX_SCALING_BASE / math.max(distance, 0.1), BOX_MIN_SIZE, BOX_MAX_SIZE); billboard.Size = UDim2.new(0, scaleFactor, 0, scaleFactor * 1.5); billboard.Enabled = true; if billboard.BoxContainer then for _, frame in ipairs(billboard.BoxContainer:GetChildren()) do if frame:IsA("Frame") then frame.BackgroundColor3 = boxColor end end end else if activeBillboards[player] then activeBillboards[player]:Destroy(); activeBillboards[player] = nil end end; if featureStates["Chams"] then local chamsHighlight = activeChamsHighlights[player]; local chamsColor = featureColors["Chams"]; if not chamsHighlight or not chamsHighlight.Parent then chamsHighlight = Instance.new("Highlight"); chamsHighlight.Name = "ChamsHighlight"; chamsHighlight.Adornee = character; chamsHighlight.FillColor = chamsColor; chamsHighlight.FillTransparency = 0; chamsHighlight.OutlineTransparency = 1; chamsHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; chamsHighlight.Enabled = true; chamsHighlight.Parent = character; activeChamsHighlights[player] = chamsHighlight elseif chamsHighlight.Adornee ~= character then chamsHighlight.Adornee = character; chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor else chamsHighlight.Enabled = true; chamsHighlight.FillColor = chamsColor end else if activeChamsHighlights[player] then activeChamsHighlights[player]:Destroy(); activeChamsHighlights[player] = nil end end else if activeBillboards[player] then activeBillboards[player]:Destroy(); activeBillboards[player] = nil end; if activeChamsHighlights[player] then activeChamsHighlights[player]:Destroy(); activeChamsHighlights[player] = nil end end end; for player, billboard in pairs(activeBillboards) do if not playersToUpdate[player] then billboard:Destroy(); activeBillboards[player] = nil end end; for player, chamsHighlight in pairs(activeChamsHighlights) do if not playersToUpdate[player] then chamsHighlight:Destroy(); activeChamsHighlights[player] = nil end end end

--[[ Input Handling ]]
local function handleMenuToggle(actionName, inputState, inputObject) if inputState == Enum.UserInputState.Begin then isMenuVisible = not isMenuVisible; if menuFrame then menuFrame.Visible = isMenuVisible end; if not isMenuVisible and colorPickerFrame then colorPickerFrame.Visible = false; currentEditingFeature = nil end end; return Enum.ContextActionResult.Pass end
ContextActionService:BindAction(MENU_TOGGLE_ACTION, handleMenuToggle, false, Enum.KeyCode.RightShift)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
	if isChangingFlyKeybind then -- Handle keybind changing input first
		if input.UserInputType == Enum.UserInputType.Keyboard then
			if input.KeyCode ~= Enum.KeyCode.Unknown and input.KeyCode ~= Enum.KeyCode.Escape then -- Accept valid keys, ignore Escape/Unknown
				flyKeybind = input.KeyCode
				flyKeybindButton.Text = flyKeybind.Name
				print("Fly keybind set to:", flyKeybind.Name)
			else
				flyKeybindButton.Text = flyKeybind.Name -- Revert text if Escape/Unknown pressed
			end
			flyKeybindButton.TextColor3 = Color3.fromRGB(220, 220, 220) -- Revert color
			isChangingFlyKeybind = false
		end
		return -- Stop further processing
	end

	-- Ignore input if the game processed it (e.g., typing in chat) OR if the menu/color picker is visible
	if gameProcessedEvent or isMenuVisible or (colorPickerFrame and colorPickerFrame.Visible) then return end

	-- Handle Fly Toggle Keybind
	if input.KeyCode == flyKeybind then
		if featureStates["Fly"] then -- Only toggle if Fly is enabled in the menu
			if isFlying then
				stopFlying()
			else
				startFlying()
			end
		end
	end
end)

--[[ Initialization ]]
RunService.Heartbeat:Connect(updateEspAndChams)
screenGui.Parent = playerGui
print("ESP Menu Script Loaded (v_fly_toggle). Menu visible. Press RightShift to toggle.")
